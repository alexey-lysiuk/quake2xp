//calc view angles
uniform vec3			u_viewOriginES;

varying vec3			v_viewVecTS;
varying vec3			v_positionVS;
varying vec3			v_tbn[3];

varying vec2			v_wTexCoord;
varying vec2			v_lTexCoord;
varying vec2			v_envCoord;

attribute vec3			a_tangent;
attribute vec3			a_binormal;
attribute vec3			a_vertArray;
attribute vec3			a_normArray;
attribute vec2			a_texCoord;
attribute vec2			a_LtexCoord;

void main ()
{
// setup tex coords
v_wTexCoord = a_texCoord;  // diffuse, addative, caustics
v_lTexCoord = a_LtexCoord; // lightmap only


vec3 u = normalize( vec3(gl_ModelViewMatrix * vec4(a_vertArray, 1.0)) );
vec3 n = normalize(gl_NormalMatrix * a_normArray);
vec3 r = reflect( u, n );
float m = 2.0 * sqrt( r.x*r.x + r.y*r.y + (r.z+1.0)*(r.z+1.0) );
v_envCoord.x = r.x/m + 0.5;
v_envCoord.y = r.y/m + 0.5;

// calculate tangent space view vector for parallax
vec3 tmp = u_viewOriginES - a_vertArray;
v_viewVecTS.x = dot(tmp, a_tangent);
v_viewVecTS.y = dot(tmp, a_binormal);
v_viewVecTS.z = dot(tmp, a_normArray);

v_tbn[0] = (gl_ModelViewMatrix * vec4(a_tangent, 0.0)).xyz;
v_tbn[1] = (gl_ModelViewMatrix * vec4(a_binormal, 0.0)).xyz;
v_tbn[2] = (gl_ModelViewMatrix * vec4(a_normArray, 0.0)).xyz;
v_positionVS = gl_ModelViewMatrix * vec4(a_vertArray, 1.0);

gl_Position = gl_ModelViewProjectionMatrix * vec4(a_vertArray, 1.0);
}
